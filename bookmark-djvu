#!/usr/bin/env perl
# This program is free software; you
# can redistribute it and/or modify it under the same terms
# as Perl 5.10.0. 
# Copyright (C), 2014, 2015 Simon Reinhardt
use 5.014;
use warnings;
use strict;
use autodie;
use utf8;
use Getopt::Long qw/:config no_ignore_case bundling/;
use File::Temp qw/tempfile/;
use File::Basename;

binmode STDOUT, ':encoding(UTF-8)'; 
binmode STDIN, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

$_ = decode ('UTF-8', $_) for @ARGV;

my $prog_name = basename ($0);
my $outfile;
my $print_help = 0;
my $print_version = 0;

GetOptions (
    "output|o=s" => \$outfile,
    "help|h" => \$print_help,
    "version|V" => \$print_version,
    )
    or exit 1;
if ($print_help) {
    print_help ();
    exit 0;
}

if ($print_version) {
    print_version ();
    exit 0;
}

if ($#ARGV == -1) {
    state_usage ();
    die "error: need at least one non-option argument\n";
}

my $djvu_filename = $ARGV[0];

if ($ARGV[1]) {
    $bookmarks_filename = $ARGV[1];
}
else {
    $bookmarks_filename = get_default_filename ($djvu_filename);
}

if (! -e $bookmarks_filename) { 			  
    die "error: bookmarks file $bookmarks_filename does not exist.\n";
}


my $command;
open my $in_fh, '<', $bookmarks_filename;
(my $out_fh, my $out_filename) = tempfile() ;
binmode $in_fh, ':encoding(UTF-8)'; # utf8::all not working together with autodie ?
binmode $out_fh, ':encoding(UTF-8)';
my @pre_Array;
my @Array;	
my $indent = qr/\t| {4}/; # indent with tab or 4 spaces
my $regexp = qr/\A(?<tabulator>($indent)*)(?<title>.+?)(\s|\.)+(?<page>-?[0-9]+)\s*\Z/;   
# check Array
my $last_indent_depth = 0;
if ($use_nested) {
    @pre_Array = <$in_fh>;
    if ($trim) {
	s/\A\s*// foreach (@pre_Array);
    }
    if ($multline) {
	@pre_Array = join_lines(@pre_Array);
    }
    @pre_Array = apply_page_differences(@pre_Array);
    # check input indentation
    for( my $i=0; $i <= $#pre_Array; ++$i) {
	if ($pre_Array[$i] =~ /$regexp/) {
	    my $indent_depth =()= $+{tabulator} =~ /$indent/g;
	    if ($indent_depth > $last_indent_depth + 1) {
		die "too mutch indentation at line ${i}: ${pre_Array[$i]}";
	    } 
	    else {
		push @Array, $pre_Array[$i];
		$last_indent_depth = $indent_depth;
	    }
	} 
	else {
	    print STDERR "no pattern match at line ${i}: ${pre_Array[$i]}" unless $pre_Array[$i] =~ /\A\s*\Z/ ;
	}
    }
    my $last = $#Array;
    print {$out_fh} "(bookmarks\n";
    for (my $i = 0; $i <= $last; ++$i) {
	$Array[$i] =~ /$regexp/; 
	my $Page = $+{'page'} ;
	my $title = $+{'title'};
	my $indent_depth =()= $+{tabulator} =~ /$indent/g;
	# need to escape " \ and ( )
	$title = escape_djvused_special_characters($title);
	print {$out_fh} "(\"${title}\" \"#${Page}\"";
	# calculate number of closing parenthesis
	if ($i == $last) {
	    print {$out_fh} ")"x($indent_depth + 1), "\n";
	} 
	else {
	    $Array[$i+1] =~ /$regexp/;
	    my $next_indent_depth =()= $+{tabulator} =~ /$indent/g;
	    if ($next_indent_depth <= $indent_depth ) {
		print {$out_fh} ")"x($indent_depth - $next_indent_depth + 1), "\n";
	    } 
	    else { print {$out_fh} "\n";}
	}
    }
    print {$out_fh} ")\n";
} 
else { # do not use nested
    @Array = <$in_fh>;
    if ($trim) {
	s/\A\s*// foreach (@Array);
    }
    if ($multline) {
	@Array = join_lines(@Array);
    }
    @Array = apply_page_differences(@Array);
    my $last = $#Array;
    print {$out_fh} "(bookmarks\n";
    for (my $i = 0; $i <= $last; ++$i) {
	if ($Array[$i] =~ /$regexp/) {
	    my $Page = $+{'page'};
	    my $title = $+{'title'};
	    # need to escape " \ and ( )
	    $title = escape_djvused_special_characters($title);
	    print {$out_fh} "(\"${title}\" \"#${Page}\")\n";
	} 
	else {
	    print STDERR "no pattern match: $Array[$i]" unless $Array[$i] =~ /\A\s*\Z/;
	}
    }
    print {$out_fh} ")\n";
}
close $out_fh; # flush buffer
if ($djvu_filename ne $output_filename) {
    $command = "cp ".shell_quote($djvu_filename) ." ".shell_quote($output_filename);
    system_bash($command);
}
$command = "djvused ".shell_quote($output_filename)." -e ".shell_quote("set-outline ".shell_quote($out_filename))." -s";
system_bash($command);

sub escape_djvused_special_characters {
    my $title = shift;
    $title =~ s/\\/\\\\/g;	    
    $title =~ s/"/\\"/g;
    $title =~ s/\(/\\\(/g;
    $title =~ s/\)/\\\)/g;
    return $title;
}

sub system_bash {
    my $command = shift;
    say "command: $command";
    system("bash -c ".shell_quote($command));
}

sub join_lines {
    my @old_Array = @_;
    my @Array;
    my $string = "";
    my $finished_line = 1;
    foreach (@old_Array) {
	if ($finished_line) {
	    if (/$regexp/ || /\A\s*d=(?<difference>-?[0-9]+)\s*\Z/) {
		push @Array, $_;
		next;
	    }
	    else 		# line is not terminated with page number
	    {
		if (!/\A(\s|\.)*\Z/ && /\A(?<title>.+?)(\s|\.)+\Z/ ) {
		    $string = $+{'title'};
		    $finished_line = 0;
		}
	    }
	}
	else 
	{
	    if (/\A(\s|\.)*(?<title>.*?)(\s|\.)*(?<page>-?[0-9]+)\s*\Z/) { # found page number and finished the line
		$string = $string . " ". $+{'title'} . " "  . $+{'page'} . "\n";
		push @Array, $string;
		$finished_line = 1;
	    }
	    else 
	    {
		if (/\A(\s|\.)*(?<title>.+?)(\s|\.)*\Z/) {
		    $string = $string . " ". $+{'title'};
		}
	    }
	}
    }
    if (!$finished_line) {
	say STDERR "warning: could not finish line: $string";
    }
    return @Array;
}
sub apply_page_differences {
    my @old_Array = @_;
    my @Array;
    foreach (@old_Array) {
	if (/\A\s*d=(?<difference>-?[0-9]+)\s*\Z/) {
	    $difference =  $+{'difference'};
	} 
	elsif (/\A(?<title>.+?)(\s|\.)+(?<page>-?[0-9]+)\s*\Z/) {
	    push @Array, $+{'title'}. " " . ($+{'page'} + $difference);
	} 
	else {
	    print STDERR "no pattern match: $_" unless /\A\s*\Z/;
	}
    }
    return @Array;
}

sub get_default_filename {
    my $djvu_filename = shift;
    my $bookmarks_filename;
    
    if ($djvu_filename =~ /\.djvu$/) {
	($bookmarks_filename = $djvu_filename) =~ s/\.djvu/\.bm/;
    }
    else {
	$bookmarks_filename = "${djvu_filename}.bm";
    }

    return $bookmarks_filename;
}
